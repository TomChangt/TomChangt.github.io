<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS安装Docker</title>
    <url>/2021/07/22/CentOS%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<p><strong>最近用华为云新账号买了一个4核8G内存的服务器，价格很漂亮，打算用来当自己的学习服务器。</strong></p>
<p><strong>在上面装一个docker，记录一下安装过程。</strong></p>
<span id="more"></span>

<h6 id="卸载老版本"><a href="#卸载老版本" class="headerlink" title="卸载老版本"></a>卸载老版本</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>

<h6 id="安装docker基础包"><a href="#安装docker基础包" class="headerlink" title="安装docker基础包"></a>安装docker基础包</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h6 id="设置稳定仓库"><a href="#设置稳定仓库" class="headerlink" title="设置稳定仓库"></a>设置稳定仓库</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">--add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h6 id="安装Docker-Engine-Community"><a href="#安装Docker-Engine-Community" class="headerlink" title="安装Docker Engine - Community"></a>安装Docker Engine - Community</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h6 id="启动与测试"><a href="#启动与测试" class="headerlink" title="启动与测试"></a>启动与测试</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker  <span class="comment"># 启动docker</span></span><br><span class="line">docker info <span class="comment">#查看docker 信息</span></span><br></pre></td></tr></table></figure>

<h6 id="设置阿里云镜像"><a href="#设置阿里云镜像" class="headerlink" title="设置阿里云镜像"></a>设置阿里云镜像</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://akq7i31y.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/07/22/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>平时docker使用过程中会有用到日常的一些命令，记录一下。</strong></p>
<span id="more"></span>

<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.docker version #显示docker的版本信息。</span><br><span class="line">2.docker info #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">3.docker [命令] --help #帮助命令 #帮助文档的地址:https://docs.docker.com/engine/reference/commandline/build/</span><br></pre></td></tr></table></figure>



<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h4><ul>
<li><p>列出本地镜像</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明："><a href="#OPTIONS说明：" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）</li>
<li>–digests :显示镜像的摘要信息</li>
<li>-f :显示满足条件的镜像</li>
<li>–format :指定返回值的模板文件</li>
<li>–no-trunc :显示完整的镜像信息</li>
<li>-q :只显示镜像ID</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ docker images  or docker image ls #列出</span><br><span class="line">REPOSITORY(镜像的仓库源)   TAG(镜像的标签)       IMAGE ID (镜像的id)      CREATED (镜像的创建时间)      SIZE(镜像的大小)</span><br><span class="line">mysql                    latest               c8562eaf9d81           7 weeks ago                 546MB</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><ul>
<li><p>从镜像仓库中拉取或者更新指定镜像</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-1"><a href="#OPTIONS说明：-1" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :拉取所有 tagged 镜像</li>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">➜ docker pull tomcat:8</span><br><span class="line">8: Pulling from library/tomcat #如果不写tag，默认就是latest</span><br><span class="line"><span class="meta">#</span><span class="bash">分层下载: docker image 的核心 联合文件系统</span></span><br><span class="line">90fe46dd8199: Already exists</span><br><span class="line">35a4f1977689: Already exists</span><br><span class="line">bbc37f14aded: Already exists</span><br><span class="line">74e27dc593d4: Already exists</span><br><span class="line">93a01fbfad7f: Already exists</span><br><span class="line">1478df405869: Pull complete</span><br><span class="line">64f0dd11682b: Pull complete</span><br><span class="line">68ff4e050d11: Pull complete</span><br><span class="line">f576086003cf: Pull complete</span><br><span class="line">3b72593ce10e: Pull complete</span><br><span class="line">Digest: sha256:0c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df640a027</span><br><span class="line"><span class="meta">#</span><span class="bash"> 签名 防伪</span></span><br><span class="line">Status: Downloaded newer image for tomcat:8 docker.io/library/tomcat:8 #真实地址</span><br><span class="line"><span class="meta">#</span><span class="bash">等价于</span></span><br><span class="line">docker pull tomcat:8</span><br><span class="line">docker pull docker.io/library/tomcat:8</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h4><ul>
<li> 删除本地一个或多少镜像</li>
</ul>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-2"><a href="#OPTIONS说明：-2" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :强制删除</li>
<li>–no-prune :不移除该镜像的过程镜像，默认移除</li>
</ul>
<h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ docker rmi -f 镜像id #删除指定的镜像</span><br><span class="line">➜ docker rmi -f $(docker images -aq) #删除全部的镜像</span><br></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><ul>
<li><p>创建一个新的容器并运行一个命令</p>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-3"><a href="#OPTIONS说明：-3" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项</li>
<li>-d: 后台运行容器，并返回容器ID</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li>-P: 随机端口映射，容器内部端口随机映射到主机的端口</li>
<li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</li>
<li>–name=”nginx-lb”: 为容器指定一个名称</li>
<li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致</li>
<li>-h “mars”: 指定容器的hostname</li>
<li>-e username=”ritchie”: 设置环境变量</li>
<li>–env-file=[]: 从指定文件读入环境变量</li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行</li>
<li>-m : 设置容器使用内存最大值</li>
<li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型</li>
<li>–link=[]: 添加链接到另一个容器</li>
<li>–expose=[]: 开放一个端口或一组端口</li>
<li>–volume , -v: 绑定一个卷</li>
</ul>
<h5 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span></span><br><span class="line">➜ docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span></span><br><span class="line">➜ docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br><span class="line">➜ docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h4><ul>
<li><p>列出容器</p>
<h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-4"><a href="#OPTIONS说明：-4" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :显示所有的容器，包括未运行的</li>
<li>-n :列出最近创建的n个容器</li>
<li>-q :静默模式，只显示容器编号</li>
<li>-s :显示总的文件大小</li>
</ul>
<h5 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有在运行的容器信息</span></span><br><span class="line">➜ docker ps</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出最近创建的5个容器信息</span></span><br><span class="line">➜ docker ps -n 5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有创建的容器ID</span></span><br><span class="line">➜ docker ps -a -q</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h4><ul>
<li><p>删除一个或多个容器</p>
<h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-5"><a href="#OPTIONS说明：-5" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :通过 SIGKILL 信号强制删除一个运行中的容器</li>
<li>-l :移除容器间的网络连接，而非容器本身</li>
<li>-v :删除与容器关联的卷</li>
</ul>
<h5 id="实例：-3"><a href="#实例：-3" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">强制删除容器 db01、db02</span></span><br><span class="line">➜ docker rm -f db01 db02</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除容器 nginx01, 并删除容器挂载的数据卷</span></span><br><span class="line">➜ docker rm -v nginx01</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除所有已经停止的容器</span></span><br><span class="line">➜ docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><ul>
<li><p>在运行的容器中执行命令</p>
<h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-6"><a href="#OPTIONS说明：-6" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-d :分离模式: 在后台运行</li>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端</li>
</ul>
<h5 id="实例：-4"><a href="#实例：-4" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</span></span><br><span class="line">➜ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在容器 mynginx 中开启一个交互模式的终端</span></span><br><span class="line">➜ docker exec -it  mynginx /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过 <span class="built_in">exec</span> 命令对指定的容器执行 bash</span></span><br><span class="line">➜ docker exec -it 9df70f9a0714 /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h4><ul>
<li><p>获取容器/镜像的元数据</p>
<h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure>



<h5 id="OPTIONS说明：-7"><a href="#OPTIONS说明：-7" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :指定返回值的模板文件</li>
<li>-s :显示总的文件大小</li>
<li>–type :为指定类型返回JSON</li>
</ul>
<h5 id="实例：-5"><a href="#实例：-5" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取镜像mysql:5.6的元信息</span></span><br><span class="line">➜ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;mysql:5.6&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;3306/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取正在运行的容器mymysql的 IP</span></span><br><span class="line">➜ docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h4><ul>
<li><p>获取容器的日志</p>
<h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>



<h5 id="OPTIONS说明：-8"><a href="#OPTIONS说明：-8" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<h5 id="实例：-6"><a href="#实例：-6" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">跟踪查看容器mynginx的日志输出</span></span><br><span class="line">➜ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看容器mynginx从2016年7月1日后的最新10条日志</span></span><br><span class="line">➜ docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><p>进入当前正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 <span class="comment"># 命令</span></span></span><br><span class="line">➜ docker exec -it 容器id bashshell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">➜ docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">区别</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">exec</span> <span class="comment">#进入当前容器后开启一个新的终端，可以在里面操作。(常用)</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash">docker attach <span class="comment">#进入容器正在执行的终端</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>从容器内拷贝到主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 主机目的路径</span><br><span class="line"><span class="meta">#</span><span class="bash">例子:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入docker容器内部</span></span><br><span class="line">➜ docker exec -it 55321bcae33d /bin/bash</span><br><span class="line">[root@55321bcae33d /]# ls</span><br><span class="line">bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr</span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个文件</span></span><br><span class="line">[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java</span><br><span class="line">[root@55321bcae33d /]# cat java.java</span><br><span class="line">hello</span><br><span class="line">[root@55321bcae33d /]# exit</span><br><span class="line">➜ docker cp 55321bcae33d:/java.java / #拷贝</span><br><span class="line">➜ cd/</span><br><span class="line">  /ls #可以看见java.java存在</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的所有命令图解</p>
<p><img data-src="/2021/07/22/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image.png" alt="image"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（1）整体架构</title>
    <url>/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><strong>如何使用 MySQL 固然重要，但是就像学习 Java那样，不了解 JVM 很多东西都寸步难行。同样的学习 MySQL 数据库前要先了解它的体系结构，这是学好 MySQL 数据库的前提。因此这里把 MySQL 的整体架构做个笔记整理一下。</strong></p>
<span id="more"></span>

<h5 id="结构总览"><a href="#结构总览" class="headerlink" title="结构总览"></a>结构总览</h5><p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/01.png"></p>
<p>从上图可以发现，MySQL由以下几部分组成：</p>
<p>MySQL驱动：</p>
<ul>
<li>作用：跟数据库建立一个网络连接。</li>
<li>Java语言开发的系统，MySQL会提供Java版本的MySQL驱动，对于PHP、Perl、.NET、Python、Ruby等各种常见的编程语言，<br>MySQL都会提供对应语言的MySQL驱动，让各种语言编写的系统通过MySQL驱动去访问数据库。</li>
</ul>
<p>数据库连接池：</p>
<ul>
<li>作用：在连接池里面维护了多个MySQL的连接，让多个线程使用里面的不同的数据库连接去执行SQL语句,然后执行完SQL语句之后，不要销毁这个数据库连接，而是把连接放回池子里，后续还可以继续使用。</li>
<li>常见的数据库连接池有DBCP，C3P0，Druid，等等。</li>
</ul>
<p>MySQL数据库的连接池：</p>
<ul>
<li>MySQL中的连接池维护了与系统之间的多个数据库连接。除此之外，你的系统每次跟MySQL建立连接的时候，<br>还会根据你传递过来的账号和密码，进行账号密码的验证，库表权限的验证。</li>
</ul>
<p>SQL接口：</p>
<ul>
<li><strong>负责处理接收到的SQL语句</strong>，他是一套执行SQL语句的接口，专门用于执行我们发送给MySQL的那些增删改查的SQL语句</li>
</ul>
<p>查询解析器：</p>
<ul>
<li><p><strong>让MySQL能看懂SQL语句。</strong>所谓的SQL解析，就是按照既定的SQL语法，对我们按照SQL语法规则编写的SQL语句进行解析，<br>然后理解这个SQL语句要干什么事情。比如：select id,name,age from users where id=1；解析后可能拆解成以下几个部分：</p>
<p>1.我们现在要从“users”表里查询数据</p>
<p>2.查询“id”字段的值等于1的那行数据</p>
<p>3.对查出来的那行数据要提取里面的“id,name,age”三个字段。</p>
</li>
</ul>
<p>查询优化器：</p>
<ul>
<li>选择最优的查询路径。他会针对你编写的几十行、几百行甚至上千行的复杂SQL语句生成查询路径树，<br>然后从里面选择一条最优的查询路径出来。</li>
</ul>
<p>执行器：</p>
<ul>
<li>根据执行计划调用存储引擎的接口。执行器会根据优化器选择的执行方案，去调用存储引擎的接口<br>按照一定的顺序和步骤，就把SQL语句的逻辑给执行了。</li>
</ul>
<p>存储引擎：</p>
<ul>
<li>存储引擎其实就是执行SQL语句的，他会按照一定的步骤去查询内存缓存数据，更新磁盘数据，查询磁盘数据，等等一系列的操作。</li>
</ul>
<h5 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h5><p>MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎，从上图中也可以看到，MySql支持很多种存储引擎。需要特别注意的是，<strong>存储引擎是基于表的</strong>，而不是数据库。</p>
<p>所以每个表都可以设置为不同的引擎，以满足业务需求</p>
<p>插件式存储引擎的好处是：能够根据具体的应用的特点选择不同的存储引擎。下面是几种 MySQL 常用的存储引擎。</p>
<p>查看当支持的全部存储引擎</p>
<p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/02.png"></p>
<p>在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。Support列的值表示某种引擎是否能使用：YES表示可以使用、NO表示不能使用、DEFAULT表示该引擎为当前默认的存储引擎。</p>
<p>如果要想查看数据库默认使用哪个引擎，可以通过使用命令：</p>
<p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/03.png"></p>
<h6 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h6><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。</p>
<p>InnoDB 为 MySQL 提供了具有提交、回滚和崩溃恢复能力的 <strong>事务安全（ACID兼容）存储引擎</strong>。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表和其他 MySQL 的表类型混合起来，甚至在同一个查询中也可以混合</p>
<p>InnoDB 存储引擎为在 <strong>主内存中缓存数据和索引而维持它自己的缓冲池</strong>。InnoDB 将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存放在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</p>
<p>InnoDB 支持 <strong>外键完整性约束</strong>，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个6字节的 ROWID（行 Id），并以此作为主键</p>
<p>使用 InnoDB 存储引擎 MySQL 将在数据目录下创建一个名为 ibdata1 的 10MB 大小的 <strong>自动扩展数据文件</strong>，以及两个名为 ib_logfile0 和 ib_logfile1 的 5MB 大小的日志文件</p>
<h6 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h6><p>MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。<strong>MyISAM 拥有较高的插入、查询速度，但不支持事务</strong>。</p>
<p>MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP 数据库应用。此外，MyISAM 存储引擎的另一个与众不同的地方是它的缓冲池 <strong>只缓存（cache）索引文件，而不缓冲数据文件</strong>，这点和大多数的数据库都非常不同。从MySQL 5.0版本开始，MyISAM 默认支持256TB 的单表数据，这足够满足一般应用需求。</p>
<p>使用 MyISAM 引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：<code>frm</code> 文件存储表定义、数据文件的扩展名为 <code>.MYD</code>（MYData）、索引文件的扩展名时 <code>.MYI</code>（MYIndex）</p>
<h6 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h6><p>Memory存储引擎（之前称HEAP存储引擎）<strong>将表中的数据存放在内存中</strong>，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。</p>
<p>虽然 Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持 TEXT 和 BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存。</p>
<p>此外有一点容易被忽视，MySQL 数据库使用 Memory 存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于 Memory 存储引擎表的容量设置，又或者中间结果含有 TEXT或 BLOB列类型字段，则 MySQL数据库会把其转换到 MyISAM存储引擎表而存放到磁盘中。之前提到 MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<blockquote>
<p><em><strong>同一个数据库也可以使用多种存储引擎的表。</strong></em><br><em><strong>如果一个表要求比较高的事务处理，可以选择InnoDB；</strong></em><br><em><strong>可以将查询要求比较高的表选择MyISAM存储；</strong></em><br><em><strong>如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github 博客搭建教程</title>
    <url>/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>最近有想法重新开始写博客了,随着年纪越来越大,需要有些沉淀的东西.16年的时候用hexo+github搭建过博客系统,于是花了点时间重新弄了一遍.我就稍稍分享一下搭建过程,当作是我这个博客的第一篇文章.</strong></p>
<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ul>
<li>macOS Big Sur 11.4</li>
<li>node v14.17.1</li>
<li>npm v6.14.13</li>
<li>git v2.30.1</li>
</ul>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>因为本人本身是后端开发,加上系统用的是macOS,所有git和node都有提前装好,网上很多mac下安装git和node的教程,我这里就不阐述了.安装好git和node以后开始安装Hexo.找一个合适的目录来存放你的博客文件,比如我这里新建了一个blog文件夹来放置我的博客文件 ~/WorkStation/WorkStation/blog,进入blog文件夹下开始安装.</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h4 id="安装必要组件"><a href="#安装必要组件" class="headerlink" title="安装必要组件"></a>安装必要组件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h4 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h4><ul>
<li><strong>Hexo经常会用到的命令:</strong><ul>
<li><strong>hexo clean：</strong>清除内容</li>
<li><strong>hexo g：生成博客</strong></li>
<li><strong>hexo s</strong>：启动服务</li>
<li><strong>hexo d：</strong>发布服务</li>
</ul>
</li>
</ul>
<p>Hexo命令大多可以缩写,比如 <em><strong>hexo s 、 hexo d</strong></em>  等等.更多详细命令可以参照<a href="https://hexo.io/zh-cn/docs/commands.html">官方文档</a></p>
<h3 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h3><h4 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h4><p><strong>在自己的github上新建一个repository,这里注意一下我名字tomchangt,所以我的repository <a href="http://name要填写tomchangt.github.io/">name要填写tomchangt.github.io</a>,名字遵从 yourname.github.io格式,不过这里填错了也没关系,后面可以修改回来.</strong></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/03.png"></p>
<h4 id="链接github与本地"><a href="#链接github与本地" class="headerlink" title="链接github与本地"></a>链接github与本地</h4><p><strong>打开terminal,然后输入下面命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>生成密钥SSH key:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后找到刚才生成的.ssh文件下的文件id_rsa.pub密钥,用文本编辑器打开复制里面的内容.</strong></p>
<p><strong>打开你的github,在点击settings,在点击SSH and GPG keys,新建一个ssh,名字可以随便.然后将刚才复制id_rsa.pub里的内容复制到key里面,点击add ssh key即可.</strong></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/05.png"></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/06.png"></p>
<h4 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h4><p><strong>在Hexo目录下的_config.yml文件下修改以下信息:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment"># Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">https://github.com/xxxx/xxxx.github.io.git</span> </span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p><strong>安装hexo deployer插件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p><strong>执行下面命令,将hexo生成静态文件提交到github上,过一会你就可以在<a href="https://xxxxxx.github.io下看到博客内容了/">https://xxxxxx.github.io下看到博客内容了</a>.</strong></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>简单的就写这么多吧,其实网上Hexo+Github建博客教程太多了,我也只是记录以下我建立博客的一个过程,并且将它当作我博客的第一篇文章,算是一个新的开始吧.</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（2）SQL语句是如何执行的</title>
    <url>/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p><strong>本文会分析下一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。</strong></p>
<span id="more"></span>

<h5 id="MySQL-基本架构概览"><a href="#MySQL-基本架构概览" class="headerlink" title="MySQL 基本架构概览"></a>MySQL 基本架构概览</h5><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p><img data-src="/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/01.png"></p>
<ul>
<li><strong>连接器：</strong>身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong>执行语句，然后从存储引擎返回数据。</li>
</ul>
<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h5 id="Server-层基本组件介绍"><a href="#Server-层基本组件介绍" class="headerlink" title="Server 层基本组件介绍"></a>Server 层基本组件介绍</h5><h6 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h6><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h6 id="查询缓存-MySQL-8-0-版本后移除"><a href="#查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="查询缓存(MySQL 8.0 版本后移除)"></a>查询缓存(MySQL 8.0 版本后移除)</h6><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h6 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h6><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p>第二步，语法分析，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h6 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h6><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h6 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h6><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h5 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h5><h6 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h6><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“tom”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“tom”的学生。</span><br></pre></td></tr></table></figure>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h6 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h6><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有人会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h5 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h5><p>下面这个图代表一条更新语句的执行流程:</p>
<p><img data-src="/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/02.png"></p>
<ul>
<li><p>redo log刷盘策略 ,参数 <code>innodb_flush_log_at_trx_commit</code></p>
<ul>
<li>值为 0 ：提交事务后，不会把 redo log buffer 里的日志刷到磁盘。此时如果 MySQL 宕机，redo log buffer 内数据全部丢失</li>
<li>值为 1 ：提交事务后立刻把日志刷到磁盘，只要提交事务成功，那 redo log 一定在磁盘</li>
<li>值为 2 ：提交事务后会把 redo log 先刷到 os cache(操作系统缓存) 里 ，然后 os cache 在适当的时机刷入磁盘<br>在os cache 没刷磁盘期间，如果 MySQL 宕机，这部分数据会丢失</li>
</ul>
</li>
<li><p>binlog刷盘策略,参数：<code>sync_binlog</code></p>
<ul>
<li>值为0：先刷到os cache缓存，然后不定时刷入磁盘。如果宕机，可能会丢失数据。</li>
<li>值为1：直接刷到磁盘文件中，是要提交事务成功，数据一定不会丢失。</li>
</ul>
</li>
</ul>
<p><strong>redo log和binlog的刷盘策略都设置成1，保证数据在提交的时候不会丢失数据。</strong></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
