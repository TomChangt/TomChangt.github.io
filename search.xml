<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CentOS安装Docker</title>
    <url>/2021/07/22/CentOS%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<p><strong>最近用华为云新账号买了一个4核8G内存的服务器，价格很漂亮，打算用来当自己的学习服务器。</strong></p>
<p><strong>在上面装一个docker，记录一下安装过程。</strong></p>
<span id="more"></span>

<h6 id="卸载老版本"><a href="#卸载老版本" class="headerlink" title="卸载老版本"></a>卸载老版本</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker \</span><br><span class="line">docker-client \</span><br><span class="line">docker-client-latest \</span><br><span class="line">docker-common \</span><br><span class="line">docker-latest \</span><br><span class="line">docker-latest-logrotate \</span><br><span class="line">docker-logrotate \</span><br><span class="line">docker-engine</span><br></pre></td></tr></table></figure>

<h6 id="安装docker基础包"><a href="#安装docker基础包" class="headerlink" title="安装docker基础包"></a>安装docker基础包</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<h6 id="设置稳定仓库"><a href="#设置稳定仓库" class="headerlink" title="设置稳定仓库"></a>设置稳定仓库</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum-config-manager \</span><br><span class="line">--add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h6 id="安装Docker-Engine-Community"><a href="#安装Docker-Engine-Community" class="headerlink" title="安装Docker Engine - Community"></a>安装Docker Engine - Community</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<h6 id="启动与测试"><a href="#启动与测试" class="headerlink" title="启动与测试"></a>启动与测试</h6><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker  <span class="comment"># 启动docker</span></span><br><span class="line">docker info <span class="comment">#查看docker 信息</span></span><br></pre></td></tr></table></figure>

<h6 id="设置阿里云镜像"><a href="#设置阿里云镜像" class="headerlink" title="设置阿里云镜像"></a>设置阿里云镜像</h6><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://akq7i31y.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Github 博客搭建教程</title>
    <url>/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><strong>最近有想法重新开始写博客了,随着年纪越来越大,需要有些沉淀的东西.16年的时候用hexo+github搭建过博客系统,于是花了点时间重新弄了一遍.我就稍稍分享一下搭建过程,当作是我这个博客的第一篇文章.</strong></p>
<span id="more"></span>

<h3 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h3><ul>
<li>macOS Big Sur 11.4</li>
<li>node v14.17.1</li>
<li>npm v6.14.13</li>
<li>git v2.30.1</li>
</ul>
<h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>因为本人本身是后端开发,加上系统用的是macOS,所有git和node都有提前装好,网上很多mac下安装git和node的教程,我这里就不阐述了.安装好git和node以后开始安装Hexo.找一个合适的目录来存放你的博客文件,比如我这里新建了一个blog文件夹来放置我的博客文件 ~/WorkStation/WorkStation/blog,进入blog文件夹下开始安装.</p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h4 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>

<h4 id="安装必要组件"><a href="#安装必要组件" class="headerlink" title="安装必要组件"></a>安装必要组件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h4 id="使用-Hexo"><a href="#使用-Hexo" class="headerlink" title="使用 Hexo"></a>使用 Hexo</h4><ul>
<li><strong>Hexo经常会用到的命令:</strong><ul>
<li><strong>hexo clean：</strong>清除内容</li>
<li><strong>hexo g：生成博客</strong></li>
<li><strong>hexo s</strong>：启动服务</li>
<li><strong>hexo d：</strong>发布服务</li>
</ul>
</li>
</ul>
<p>Hexo命令大多可以缩写,比如 <em><strong>hexo s 、 hexo d</strong></em>  等等.更多详细命令可以参照<a href="https://hexo.io/zh-cn/docs/commands.html">官方文档</a></p>
<h3 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h3><h4 id="创建Repository"><a href="#创建Repository" class="headerlink" title="创建Repository"></a>创建Repository</h4><p><strong>在自己的github上新建一个repository,这里注意一下我名字tomchangt,所以我的repository <a href="http://name要填写tomchangt.github.io/">name要填写tomchangt.github.io</a>,名字遵从 yourname.github.io格式,不过这里填错了也没关系,后面可以修改回来.</strong></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/03.png"></p>
<h4 id="链接github与本地"><a href="#链接github与本地" class="headerlink" title="链接github与本地"></a>链接github与本地</h4><p><strong>打开terminal,然后输入下面命令:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的GitHub用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>生成密钥SSH key:</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的GitHub注册邮箱&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>然后找到刚才生成的.ssh文件下的文件id_rsa.pub密钥,用文本编辑器打开复制里面的内容.</strong></p>
<p><strong>打开你的github,在点击settings,在点击SSH and GPG keys,新建一个ssh,名字可以随便.然后将刚才复制id_rsa.pub里的内容复制到key里面,点击add ssh key即可.</strong></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/05.png"></p>
<p><img data-src="/2021/07/21/Hexo-Github-%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/06.png"></p>
<h4 id="配置本地hexo"><a href="#配置本地hexo" class="headerlink" title="配置本地hexo"></a>配置本地hexo</h4><p><strong>在Hexo目录下的_config.yml文件下修改以下信息:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment"># Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">repository:</span> <span class="string">https://github.com/xxxx/xxxx.github.io.git</span> </span><br><span class="line"><span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p><strong>安装hexo deployer插件</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p><strong>执行下面命令,将hexo生成静态文件提交到github上,过一会你就可以在<a href="https://xxxxxx.github.io下看到博客内容了/">https://xxxxxx.github.io下看到博客内容了</a>.</strong></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><strong>简单的就写这么多吧,其实网上Hexo+Github建博客教程太多了,我也只是记录以下我建立博客的一个过程,并且将它当作我博客的第一篇文章,算是一个新的开始吧.</strong></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/07/22/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>平时docker使用过程中会有用到日常的一些命令，记录一下。</strong></p>
<span id="more"></span>

<h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1.docker version #显示docker的版本信息。</span><br><span class="line">2.docker info #显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">3.docker [命令] --help #帮助命令 #帮助文档的地址:https://docs.docker.com/engine/reference/commandline/build/</span><br></pre></td></tr></table></figure>



<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><h4 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h4><ul>
<li><p>列出本地镜像</p>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明："><a href="#OPTIONS说明：" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）</li>
<li>–digests :显示镜像的摘要信息</li>
<li>-f :显示满足条件的镜像</li>
<li>–format :指定返回值的模板文件</li>
<li>–no-trunc :显示完整的镜像信息</li>
<li>-q :只显示镜像ID</li>
</ul>
<h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ docker images  or docker image ls #列出</span><br><span class="line">REPOSITORY(镜像的仓库源)   TAG(镜像的标签)       IMAGE ID (镜像的id)      CREATED (镜像的创建时间)      SIZE(镜像的大小)</span><br><span class="line">mysql                    latest               c8562eaf9d81           7 weeks ago                 546MB</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h4><ul>
<li><p>从镜像仓库中拉取或者更新指定镜像</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-1"><a href="#OPTIONS说明：-1" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :拉取所有 tagged 镜像</li>
<li>–disable-content-trust :忽略镜像的校验,默认开启</li>
</ul>
<h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载镜像 docker pull 镜像名[:tag]</span></span><br><span class="line">➜ docker pull tomcat:8</span><br><span class="line">8: Pulling from library/tomcat #如果不写tag，默认就是latest</span><br><span class="line"><span class="meta">#</span><span class="bash">分层下载: docker image 的核心 联合文件系统</span></span><br><span class="line">90fe46dd8199: Already exists</span><br><span class="line">35a4f1977689: Already exists</span><br><span class="line">bbc37f14aded: Already exists</span><br><span class="line">74e27dc593d4: Already exists</span><br><span class="line">93a01fbfad7f: Already exists</span><br><span class="line">1478df405869: Pull complete</span><br><span class="line">64f0dd11682b: Pull complete</span><br><span class="line">68ff4e050d11: Pull complete</span><br><span class="line">f576086003cf: Pull complete</span><br><span class="line">3b72593ce10e: Pull complete</span><br><span class="line">Digest: sha256:0c6234e7ec9d10ab32c06423ab829b32e3183ba5bf2620ee66de866df640a027</span><br><span class="line"><span class="meta">#</span><span class="bash"> 签名 防伪</span></span><br><span class="line">Status: Downloaded newer image for tomcat:8 docker.io/library/tomcat:8 #真实地址</span><br><span class="line"><span class="meta">#</span><span class="bash">等价于</span></span><br><span class="line">docker pull tomcat:8</span><br><span class="line">docker pull docker.io/library/tomcat:8</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h4><ul>
<li> 删除本地一个或多少镜像</li>
</ul>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-2"><a href="#OPTIONS说明：-2" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :强制删除</li>
<li>–no-prune :不移除该镜像的过程镜像，默认移除</li>
</ul>
<h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5>  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜ docker rmi -f 镜像id #删除指定的镜像</span><br><span class="line">➜ docker rmi -f $(docker images -aq) #删除全部的镜像</span><br></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><h4 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h4><ul>
<li><p>创建一个新的容器并运行一个命令</p>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-3"><a href="#OPTIONS说明：-3" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项</li>
<li>-d: 后台运行容器，并返回容器ID</li>
<li>-i: 以交互模式运行容器，通常与 -t 同时使用</li>
<li>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用</li>
<li>-P: 随机端口映射，容器内部端口随机映射到主机的端口</li>
<li>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</li>
<li>–name=”nginx-lb”: 为容器指定一个名称</li>
<li>–dns 8.8.8.8: 指定容器使用的DNS服务器，默认和宿主一致</li>
<li>-h “mars”: 指定容器的hostname</li>
<li>-e username=”ritchie”: 设置环境变量</li>
<li>–env-file=[]: 从指定文件读入环境变量</li>
<li>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定CPU运行</li>
<li>-m : 设置容器使用内存最大值</li>
<li>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型</li>
<li>–link=[]: 添加链接到另一个容器</li>
<li>–expose=[]: 开放一个端口或一组端口</li>
<li>–volume , -v: 绑定一个卷</li>
</ul>
<h5 id="实例：-1"><a href="#实例：-1" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</span></span><br><span class="line">➜ docker run --name mynginx -d nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用镜像 nginx:latest，以后台模式启动一个容器,将容器的 80 端口映射到主机的 80 端口,主机的目录 /data 映射到容器的 /data。</span></span><br><span class="line">➜ docker run -p 80:80 -v /data:/data -d nginx:latest</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br><span class="line">➜ docker run -it nginx:latest /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-ps"><a href="#docker-ps" class="headerlink" title="docker ps"></a>docker ps</h4><ul>
<li><p>列出容器</p>
<h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker ps [OPTIONS]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-4"><a href="#OPTIONS说明：-4" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-a :显示所有的容器，包括未运行的</li>
<li>-n :列出最近创建的n个容器</li>
<li>-q :静默模式，只显示容器编号</li>
<li>-s :显示总的文件大小</li>
</ul>
<h5 id="实例：-2"><a href="#实例：-2" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有在运行的容器信息</span></span><br><span class="line">➜ docker ps</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出最近创建的5个容器信息</span></span><br><span class="line">➜ docker ps -n 5</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">列出所有创建的容器ID</span></span><br><span class="line">➜ docker ps -a -q</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-rm"><a href="#docker-rm" class="headerlink" title="docker rm"></a>docker rm</h4><ul>
<li><p>删除一个或多个容器</p>
<h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-5"><a href="#OPTIONS说明：-5" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :通过 SIGKILL 信号强制删除一个运行中的容器</li>
<li>-l :移除容器间的网络连接，而非容器本身</li>
<li>-v :删除与容器关联的卷</li>
</ul>
<h5 id="实例：-3"><a href="#实例：-3" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">强制删除容器 db01、db02</span></span><br><span class="line">➜ docker rm -f db01 db02</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除容器 nginx01, 并删除容器挂载的数据卷</span></span><br><span class="line">➜ docker rm -v nginx01</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">删除所有已经停止的容器</span></span><br><span class="line">➜ docker rm $(docker ps -a -q)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-exec"><a href="#docker-exec" class="headerlink" title="docker exec"></a>docker exec</h4><ul>
<li><p>在运行的容器中执行命令</p>
<h5 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br></pre></td></tr></table></figure>

<h5 id="OPTIONS说明：-6"><a href="#OPTIONS说明：-6" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-d :分离模式: 在后台运行</li>
<li>-i :即使没有附加也保持STDIN 打开</li>
<li>-t :分配一个伪终端</li>
</ul>
<h5 id="实例：-4"><a href="#实例：-4" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在容器 mynginx 中以交互模式执行容器内 /root/runoob.sh 脚本:</span></span><br><span class="line">➜ docker exec -it mynginx /bin/sh /root/runoob.sh</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在容器 mynginx 中开启一个交互模式的终端</span></span><br><span class="line">➜ docker exec -it  mynginx /bin/bash</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通过 <span class="built_in">exec</span> 命令对指定的容器执行 bash</span></span><br><span class="line">➜ docker exec -it 9df70f9a0714 /bin/bash</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h4><ul>
<li><p>获取容器/镜像的元数据</p>
<h5 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br></pre></td></tr></table></figure>



<h5 id="OPTIONS说明：-7"><a href="#OPTIONS说明：-7" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f :指定返回值的模板文件</li>
<li>-s :显示总的文件大小</li>
<li>–type :为指定类型返回JSON</li>
</ul>
<h5 id="实例：-5"><a href="#实例：-5" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取镜像mysql:5.6的元信息</span></span><br><span class="line">➜ docker inspect mysql:5.6</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;sha256:2c0964ec182ae9a045f866bbc2553087f6e42bfc16074a74fb820af235f070ec&quot;,</span><br><span class="line">        &quot;RepoTags&quot;: [</span><br><span class="line">            &quot;mysql:5.6&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;RepoDigests&quot;: [],</span><br><span class="line">        &quot;Parent&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Comment&quot;: &quot;&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2016-05-24T04:01:41.168371815Z&quot;,</span><br><span class="line">        &quot;Container&quot;: &quot;e0924bc460ff97787f34610115e9363e6363b30b8efa406e28eb495ab199ca54&quot;,</span><br><span class="line">        &quot;ContainerConfig&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;b0cf605c7757&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;ExposedPorts&quot;: &#123;</span><br><span class="line">                &quot;3306/tcp&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取正在运行的容器mymysql的 IP</span></span><br><span class="line">➜ docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; mymysql</span><br><span class="line">172.17.0.3</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="docker-logs"><a href="#docker-logs" class="headerlink" title="docker logs"></a>docker logs</h4><ul>
<li><p>获取容器的日志</p>
<h5 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs [OPTIONS] CONTAINER</span><br></pre></td></tr></table></figure>



<h5 id="OPTIONS说明：-8"><a href="#OPTIONS说明：-8" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h5><ul>
<li>-f : 跟踪日志输出</li>
<li>–since :显示某个开始时间的所有日志</li>
<li>-t : 显示时间戳</li>
<li>–tail :仅列出最新N条容器日志</li>
</ul>
<h5 id="实例：-6"><a href="#实例：-6" class="headerlink" title="实例："></a>实例：</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">跟踪查看容器mynginx的日志输出</span></span><br><span class="line">➜ docker logs -f mynginx</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET / HTTP/1.1&quot; 200 612 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">2016/07/10 16:53:33 [error] 5#5: *1 open() &quot;/usr/share/nginx/html/favicon.ico&quot; failed (2: No such file or directory), client: 192.168.239.1, server: localhost, request: &quot;GET /favicon.ico HTTP/1.1&quot;, host: &quot;192.168.239.130&quot;, referrer: &quot;http://192.168.239.130/&quot;</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:33 +0000] &quot;GET /favicon.ico HTTP/1.1&quot; 404 571 &quot;http://192.168.239.130/&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">192.168.239.1 - - [10/Jul/2016:16:53:59 +0000] &quot;GET / HTTP/1.1&quot; 304 0 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/45.0.2454.93 Safari/537.36&quot; &quot;-&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看容器mynginx从2016年7月1日后的最新10条日志</span></span><br><span class="line">➜ docker logs --since=&quot;2016-07-01&quot; --tail=10 mynginx</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h3><ul>
<li><p>进入当前正在运行的容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置 <span class="comment"># 命令</span></span></span><br><span class="line">➜ docker exec -it 容器id bashshell</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二</span></span><br><span class="line">➜ docker attach 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash">区别</span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">exec</span> <span class="comment">#进入当前容器后开启一个新的终端，可以在里面操作。(常用)</span></span> </span><br><span class="line"><span class="meta">#</span><span class="bash">docker attach <span class="comment">#进入容器正在执行的终端</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>从容器内拷贝到主机上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker cp 容器id:容器内路径 主机目的路径</span><br><span class="line"><span class="meta">#</span><span class="bash">例子:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">进入docker容器内部</span></span><br><span class="line">➜ docker exec -it 55321bcae33d /bin/bash</span><br><span class="line">[root@55321bcae33d /]# ls</span><br><span class="line">bin etc lib lost+found mnt proc run srv tmp var dev home lib64 media opt root sbin sys usr</span><br><span class="line"><span class="meta">#</span><span class="bash">新建一个文件</span></span><br><span class="line">[root@55321bcae33d /]# echo &quot;hello&quot; &gt; java.java</span><br><span class="line">[root@55321bcae33d /]# cat java.java</span><br><span class="line">hello</span><br><span class="line">[root@55321bcae33d /]# exit</span><br><span class="line">➜ docker cp 55321bcae33d:/java.java / #拷贝</span><br><span class="line">➜ cd/</span><br><span class="line">  /ls #可以看见java.java存在</span><br></pre></td></tr></table></figure></li>
<li><p>Docker的所有命令图解</p>
<p><img data-src="/2021/07/22/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/image.png" alt="image"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（1）整体架构</title>
    <url>/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<p><strong>如何使用 MySQL 固然重要，但是就像学习 Java那样，不了解 JVM 很多东西都寸步难行。同样的学习 MySQL 数据库前要先了解它的体系结构，这是学好 MySQL 数据库的前提。因此这里把 MySQL 的整体架构做个笔记整理一下。</strong></p>
<span id="more"></span>

<h5 id="结构总览"><a href="#结构总览" class="headerlink" title="结构总览"></a>结构总览</h5><p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/01.png"></p>
<p>从上图可以发现，MySQL由以下几部分组成：</p>
<p>MySQL驱动：</p>
<ul>
<li>作用：跟数据库建立一个网络连接。</li>
<li>Java语言开发的系统，MySQL会提供Java版本的MySQL驱动，对于PHP、Perl、.NET、Python、Ruby等各种常见的编程语言，<br>MySQL都会提供对应语言的MySQL驱动，让各种语言编写的系统通过MySQL驱动去访问数据库。</li>
</ul>
<p>数据库连接池：</p>
<ul>
<li>作用：在连接池里面维护了多个MySQL的连接，让多个线程使用里面的不同的数据库连接去执行SQL语句,然后执行完SQL语句之后，不要销毁这个数据库连接，而是把连接放回池子里，后续还可以继续使用。</li>
<li>常见的数据库连接池有DBCP，C3P0，Druid，等等。</li>
</ul>
<p>MySQL数据库的连接池：</p>
<ul>
<li>MySQL中的连接池维护了与系统之间的多个数据库连接。除此之外，你的系统每次跟MySQL建立连接的时候，<br>还会根据你传递过来的账号和密码，进行账号密码的验证，库表权限的验证。</li>
</ul>
<p>SQL接口：</p>
<ul>
<li><strong>负责处理接收到的SQL语句</strong>，他是一套执行SQL语句的接口，专门用于执行我们发送给MySQL的那些增删改查的SQL语句</li>
</ul>
<p>查询解析器：</p>
<ul>
<li><p><strong>让MySQL能看懂SQL语句。</strong>所谓的SQL解析，就是按照既定的SQL语法，对我们按照SQL语法规则编写的SQL语句进行解析，<br>然后理解这个SQL语句要干什么事情。比如：select id,name,age from users where id=1；解析后可能拆解成以下几个部分：</p>
<p>1.我们现在要从“users”表里查询数据</p>
<p>2.查询“id”字段的值等于1的那行数据</p>
<p>3.对查出来的那行数据要提取里面的“id,name,age”三个字段。</p>
</li>
</ul>
<p>查询优化器：</p>
<ul>
<li>选择最优的查询路径。他会针对你编写的几十行、几百行甚至上千行的复杂SQL语句生成查询路径树，<br>然后从里面选择一条最优的查询路径出来。</li>
</ul>
<p>执行器：</p>
<ul>
<li>根据执行计划调用存储引擎的接口。执行器会根据优化器选择的执行方案，去调用存储引擎的接口<br>按照一定的顺序和步骤，就把SQL语句的逻辑给执行了。</li>
</ul>
<p>存储引擎：</p>
<ul>
<li>存储引擎其实就是执行SQL语句的，他会按照一定的步骤去查询内存缓存数据，更新磁盘数据，查询磁盘数据，等等一系列的操作。</li>
</ul>
<h5 id="常见的存储引擎"><a href="#常见的存储引擎" class="headerlink" title="常见的存储引擎"></a>常见的存储引擎</h5><p>MySQL 数据库区别于其他数据库的最重要的一个特点就是其插件式的表存储引擎，从上图中也可以看到，MySql支持很多种存储引擎。需要特别注意的是，<strong>存储引擎是基于表的</strong>，而不是数据库。</p>
<p>所以每个表都可以设置为不同的引擎，以满足业务需求</p>
<p>插件式存储引擎的好处是：能够根据具体的应用的特点选择不同的存储引擎。下面是几种 MySQL 常用的存储引擎。</p>
<p>查看当支持的全部存储引擎</p>
<p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/02.png"></p>
<p>在 MySQL 中，不需要在整个服务器中使用同一种存储引擎，针对具体的要求，可以对每一个表使用不同的存储引擎。Support列的值表示某种引擎是否能使用：YES表示可以使用、NO表示不能使用、DEFAULT表示该引擎为当前默认的存储引擎。</p>
<p>如果要想查看数据库默认使用哪个引擎，可以通过使用命令：</p>
<p><img data-src="/2021/07/23/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84/03.png"></p>
<h6 id="InnoDB存储引擎"><a href="#InnoDB存储引擎" class="headerlink" title="InnoDB存储引擎"></a>InnoDB存储引擎</h6><p>InnoDB是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。</p>
<p>InnoDB 为 MySQL 提供了具有提交、回滚和崩溃恢复能力的 <strong>事务安全（ACID兼容）存储引擎</strong>。InnoDB 锁定在行级并且也在 SELECT 语句中提供一个类似 Oracle 的非锁定读。这些功能增加了多用户部署和性能。在 SQL 查询中，可以自由地将 InnoDB 类型的表和其他 MySQL 的表类型混合起来，甚至在同一个查询中也可以混合</p>
<p>InnoDB 存储引擎为在 <strong>主内存中缓存数据和索引而维持它自己的缓冲池</strong>。InnoDB 将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与 MyISAM 表不同，比如在 MyISAM 表中每个表被存放在分离的文件中。InnoDB 表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上</p>
<p>InnoDB 支持 <strong>外键完整性约束</strong>，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB 会为每一行生成一个6字节的 ROWID（行 Id），并以此作为主键</p>
<p>使用 InnoDB 存储引擎 MySQL 将在数据目录下创建一个名为 ibdata1 的 10MB 大小的 <strong>自动扩展数据文件</strong>，以及两个名为 ib_logfile0 和 ib_logfile1 的 5MB 大小的日志文件</p>
<h6 id="MyISAM存储引擎"><a href="#MyISAM存储引擎" class="headerlink" title="MyISAM存储引擎"></a>MyISAM存储引擎</h6><p>MyISAM 基于 ISAM 存储引擎，并对其进行扩展。它是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。<strong>MyISAM 拥有较高的插入、查询速度，但不支持事务</strong>。</p>
<p>MyISAM 存储引擎不支持事务、表锁设计，支持全文索引，主要面向一些 OLAP 数据库应用。此外，MyISAM 存储引擎的另一个与众不同的地方是它的缓冲池 <strong>只缓存（cache）索引文件，而不缓冲数据文件</strong>，这点和大多数的数据库都非常不同。从MySQL 5.0版本开始，MyISAM 默认支持256TB 的单表数据，这足够满足一般应用需求。</p>
<p>使用 MyISAM 引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：<code>frm</code> 文件存储表定义、数据文件的扩展名为 <code>.MYD</code>（MYData）、索引文件的扩展名时 <code>.MYI</code>（MYIndex）</p>
<h6 id="Memory存储引擎"><a href="#Memory存储引擎" class="headerlink" title="Memory存储引擎"></a>Memory存储引擎</h6><p>Memory存储引擎（之前称HEAP存储引擎）<strong>将表中的数据存放在内存中</strong>，如果数据库重启或发生崩溃，表中的数据都将消失。它非常适合用于存储临时数据的临时表，以及数据仓库中的纬度表。Memory存储引擎默认使用哈希索引，而不是我们熟悉的B+树索引。</p>
<p>虽然 Memory存储引擎速度非常快，但在使用上还是有一定的限制。比如，只支持表锁，并发性能较差，并且不支持 TEXT 和 BLOB列类型。最重要的是，存储变长字段（varchar）时是按照定常字段（char）的方式进行的，因此会浪费内存。</p>
<p>此外有一点容易被忽视，MySQL 数据库使用 Memory 存储引擎作为临时表来存放查询的中间结果集（intermediate result）。如果中间结果集大于 Memory 存储引擎表的容量设置，又或者中间结果含有 TEXT或 BLOB列类型字段，则 MySQL数据库会把其转换到 MyISAM存储引擎表而存放到磁盘中。之前提到 MyISAM不缓存数据文件，因此这时产生的临时表的性能对于查询会有损失。</p>
<blockquote>
<p><em><strong>同一个数据库也可以使用多种存储引擎的表。</strong></em><br><em><strong>如果一个表要求比较高的事务处理，可以选择InnoDB；</strong></em><br><em><strong>可以将查询要求比较高的表选择MyISAM存储；</strong></em><br><em><strong>如果该数据库需要一个用于查询的临时表，可以选择MEMORY存储引擎。</strong></em></p>
</blockquote>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（2）SQL语句是如何执行的</title>
    <url>/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    <content><![CDATA[<p><strong>本文会分析下一个 sql 语句在 MySQL 中的执行流程，包括 sql 的查询在 MySQL 内部会怎么流转，sql 语句的更新是怎么完成的。</strong></p>
<span id="more"></span>

<h5 id="MySQL-基本架构概览"><a href="#MySQL-基本架构概览" class="headerlink" title="MySQL 基本架构概览"></a>MySQL 基本架构概览</h5><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p><img data-src="/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/01.png"></p>
<ul>
<li><strong>连接器：</strong>身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong>执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong>按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong>执行语句，然后从存储引擎返回数据。</li>
</ul>
<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h5 id="Server-层基本组件介绍"><a href="#Server-层基本组件介绍" class="headerlink" title="Server 层基本组件介绍"></a>Server 层基本组件介绍</h5><h6 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h6><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h6 id="查询缓存-MySQL-8-0-版本后移除"><a href="#查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="查询缓存(MySQL 8.0 版本后移除)"></a>查询缓存(MySQL 8.0 版本后移除)</h6><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h6 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h6><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p>第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p>第二步，语法分析，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h6 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h6><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h6 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h6><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h5 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h5><h6 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h6><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">a.先查询学生表中姓名为“tom”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“tom”的学生。</span><br></pre></td></tr></table></figure>

<p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
</li>
<li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p>
</li>
</ul>
<h6 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h6><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27;tom&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有人会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h5 id="如何保证数据不丢失"><a href="#如何保证数据不丢失" class="headerlink" title="如何保证数据不丢失"></a>如何保证数据不丢失</h5><p>下面这个图代表一条更新语句的执行流程:</p>
<p><img data-src="/2021/07/25/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89SQL%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/02.png"></p>
<ul>
<li><p>redo log刷盘策略 ,参数 <code>innodb_flush_log_at_trx_commit</code></p>
<ul>
<li>值为 0 ：提交事务后，不会把 redo log buffer 里的日志刷到磁盘。此时如果 MySQL 宕机，redo log buffer 内数据全部丢失</li>
<li>值为 1 ：提交事务后立刻把日志刷到磁盘，只要提交事务成功，那 redo log 一定在磁盘</li>
<li>值为 2 ：提交事务后会把 redo log 先刷到 os cache(操作系统缓存) 里 ，然后 os cache 在适当的时机刷入磁盘<br>在os cache 没刷磁盘期间，如果 MySQL 宕机，这部分数据会丢失</li>
</ul>
</li>
<li><p>binlog刷盘策略,参数：<code>sync_binlog</code></p>
<ul>
<li>值为0：先刷到os cache缓存，然后不定时刷入磁盘。如果宕机，可能会丢失数据。</li>
<li>值为1：直接刷到磁盘文件中，是要提交事务成功，数据一定不会丢失。</li>
</ul>
</li>
</ul>
<p><strong>redo log和binlog的刷盘策略都设置成1，保证数据在提交的时候不会丢失数据。</strong></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL学习笔记（3）Buffer Pool详解</title>
    <url>/2021/07/26/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Buffer-Pool%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><strong>应用系统分层架构，为了加速数据访问，会把最常访问的数据，放在缓存(cache)里，避免每次都去访问数据库。操作系统，会有缓冲池(buffer pool)机制，避免每次访问磁盘，以加速数据的访问，而Buffer Pool就是MySQL存储引擎为了加速数据的读取速度而设计的缓冲机制。</strong></p>
<span id="more"></span>

<h5 id="buffer-pool是什么"><a href="#buffer-pool是什么" class="headerlink" title="buffer pool是什么?"></a>buffer pool是什么?</h5><p>其实无论是连接池也好、缓存池也好，只要是XXX池，都是为加速而设计的。比如操作系统的文件系统为了加快数据的读取速度，每次都做低效率的磁盘随机IO设计了缓冲写机制。</p>
<p>而Buffer Pool就是MySQL存储引擎为了加速数据的读取速度而设计的缓冲机制。</p>
<p><img data-src="/2021/07/26/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Buffer-Pool%E8%AF%A6%E8%A7%A3/01.png"></p>
<p>如上图，Buffer中的中的单位是一个个的缓存页。缓存页本质上就是从磁盘中读取进内存的数据页。数据页中存放着一行行的记录。Buffer Pool中的默认大小为128MB(可以通过参数设置其大小：<code>innodb_buffer_pool_size</code>)，数据页大小16KB。</p>
<p>Buffer Pool中的描述信息以双向链表（LRU）的形式组织在一起。通过数据页的描述信息，我们能找它所描述的缓存页的位置。</p>
<p>看到这里你除了要知道查询缓存(<strong>8.0以后废弃了</strong>)和Buffer Pool的所属：前者属于MySQLServer层面，后者属于存储引擎层面。还需要知道另一个知识点：相对于极容易整体失效的查询缓存来说，Buffer Pool是通过InnoDB优化后的LRU算法控制将老化的数据数据从缓存中干掉的，所以Buffer Pool中缓存的数据不会像前者一样一次性整体失效。</p>
<h5 id="数据页和缓存页"><a href="#数据页和缓存页" class="headerlink" title="数据页和缓存页"></a>数据页和缓存页</h5><h6 id="什么是数据页"><a href="#什么是数据页" class="headerlink" title="什么是数据页?"></a>什么是数据页?</h6><p>是MySQL抽象出来的数据单位，默认大小是16KB，里面存放了一行行的数据。</p>
<h6 id="什么是缓存页"><a href="#什么是缓存页" class="headerlink" title="什么是缓存页?"></a>什么是缓存页?</h6><p>加载到Buffer Pool中的数据页被称为缓存页，缓存页和数据页数一一对应的。</p>
<h5 id="描述数据"><a href="#描述数据" class="headerlink" title="描述数据"></a>描述数据</h5><h6 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h6><p>每个缓存页都会对应一个描述信息，可以认为这个描述信息就是用来描述对应的缓存页的。</p>
<h6 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h6><p>大概相当于缓存页大小的5%左右，每个描述数据大概是800个字节,假设buffer pool大小是128MB，实际上Buffer Pool真正的最终大小会超出一些，可能有个130多MB的样子多出来的就是存放描述数据的。</p>
<h6 id="包含内容"><a href="#包含内容" class="headerlink" title="包含内容"></a>包含内容</h6><p>数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址、各种链表的指针。</p>
<h6 id="存储在那里的？"><a href="#存储在那里的？" class="headerlink" title="存储在那里的？"></a>存储在那里的？</h6><p>存储在Buffer Pool中。</p>
<h5 id="InnoDB的FreeList"><a href="#InnoDB的FreeList" class="headerlink" title="InnoDB的FreeList"></a>InnoDB的FreeList</h5><blockquote>
<p><em><strong>MySQL启动后，BufferPool就会被初始化，在你没有执行任何查询操作之前，BufferPool中的缓存页都是一块块空的内存，未被使用过也没有任何数据保存在里面。而且你也知道了通过缓冲页的描述信息可以直接且唯一的找到它所指向的缓存页。</strong></em></p>
<p><em><strong><font color=Blue>那你有没有想过，我们从磁盘里面读取出来的 数据页 应该放到那个缓冲页中去呢？</font></strong></em></p>
<p><em><strong>这个问题就引出了Free List。</strong></em></p>
</blockquote>
<h6 id="Free-List"><a href="#Free-List" class="headerlink" title="Free List"></a>Free List</h6><p>其实Free List是Buffer Pool中基于缓存页描述信息组织起来的双向链表。换言之，Free List中的每一个结点都是缓存页对应的描述信息。并且通过描述信息可以找到指定的缓存页（缓存页）。</p>
<p>InnoDB设计Free List的初衷就是为了解决上面说的问题。</p>
<p>如果这个缓存页中没有存储任何数据，那么它对应的描述信息就会被维护进Free List中。这时当你想把从磁盘中读取出一个数据页放入缓存页中的话，就得先从Free List中找一个节点（Free List中的所有节点都会指向一个从未被使用过的缓存页），那接着就可以把你读取出来的这个数据页放入到该节点指向的缓存页中。</p>
<p>相对应的当数据页中被放入数据之后，它对应的描述信息块会被从Free List中移出。</p>
<h6 id="如何判断数据页有没有在缓存中？"><a href="#如何判断数据页有没有在缓存中？" class="headerlink" title="如何判断数据页有没有在缓存中？"></a>如何判断数据页有没有在缓存中？</h6><p>你会不会纳闷MySQL怎么知道刚读取出来的这个数据页有没有在缓存页中呢？</p>
<p>这个功能的实现依托于另一个数据结构：**<font color=Blue>hash table</font>**</p>
<p><strong><font color=Blue>key = 表空间号+数据页号</font></strong></p>
<p><strong><font color=Blue>value = 缓存页地址</font></strong></p>
<p>如果存在于hash table中，那就说明该数据页已经存在于Buffer Pool中了，优先使用Buffer Pool中的缓存页。相信你肯定能想到为啥优先使用Buffer Pool中的缓存页吧！首先免去了磁盘的随机IO，其次缓存页中的数据可能是已经被修改了的脏数据。</p>
<h5 id="Flush-List-以及-脏页的落盘机制"><a href="#Flush-List-以及-脏页的落盘机制" class="headerlink" title="Flush List 以及 脏页的落盘机制"></a>Flush List 以及 脏页的落盘机制</h5><p>MySQL启动后Buffer Pool会初始化。Buffer Pool也会初始化好N多个空白的缓存页，以及它们的描述数据会被组织成LRU链表以及FreeList 双向链表。</p>
<p>这时你从磁盘中读取一个数据页，会先从Free List中找出一个空闲缓存页的描述信息，然后将你读出的数据页中加载进缓存页中。同时将缓存页的描述信息从Free List中剔除，此外该描述信息块还会被维护进LRU链表中。</p>
<p>数据页被加载进Buffer Pool后你就可以对其进行变更操作了。</p>
<h6 id="Flush-List"><a href="#Flush-List" class="headerlink" title="Flush List"></a>Flush List</h6><p>为了加快响应客户端的速度，MySQL会在Buffer Pool中对数据进行修改，可是一旦你对LRU链表中的缓存页做了修改，那该页中的数据和磁盘中的数据页信息就不一致了！大家一般管这种数据页叫做<strong>脏页</strong>。</p>
<p>为了保证数据的最终一致性，MySQL是需要将脏页刷新回磁盘的！</p>
<p>但是问题是：需要将哪些数据页刷新回磁盘呢？</p>
<p>这就引出了<strong>Flush List</strong>～</p>
<p>Flush List 和 Free List很像，都是由Buffer Pool中数据描述信息组织而成的双向链表。</p>
<p>一旦你对内存中的缓冲页作出了修改，那该缓冲页对应的描述信息块就会添加进 Flush List。这样当Buffer Pool中的数据页不够用时，我们就可以优先将 Flush List中的脏数据页刷新进磁盘中。</p>
<h6 id="什么是脏页？什么是脏数据"><a href="#什么是脏页？什么是脏数据" class="headerlink" title="什么是脏页？什么是脏数据"></a>什么是脏页？什么是脏数据</h6><ul>
<li><p>什么是脏页？</p>
<p>上面有提及，脏页就是LRU链表中被修改了的缓存页。他们和磁盘中的数据页不一致，脏页是需要被刷新回磁盘的。</p>
</li>
<li><p>什么是脏数据？</p>
<p>这个问题其实引出了脏读的概念。举个例子：事物A中读取到了事物B中未提交的数据，我们管这些数据叫做脏数据。</p>
</li>
</ul>
<h6 id="脏页刷回磁盘的时机"><a href="#脏页刷回磁盘的时机" class="headerlink" title="脏页刷回磁盘的时机"></a>脏页刷回磁盘的时机</h6><p>当Buffer Pool不够用时，根据LRU机制，MySQL会将Old SubList部分的缓存页移出LRU链表。如果被移除出去的缓存页的描述信息在Flush List中，MySQL就得将其刷新回磁盘。</p>
<p>InnoDB存储引擎将脏页刷回磁盘的时机有蛮多的，有如下情况：</p>
<ol>
<li>当MySQL数据库关闭时，会将所有的脏数据页刷新回磁盘。这个功能由参数：**<font color=Blue>innodb_fast_shutdown</font>** = 0控制，默认让InnoDB在关闭前将脏页刷回磁盘，以及清理掉undo log。</li>
<li>有一个后台线程Master Thread会按照每秒或者每十秒的速度，异步的将Buffer Pool中一定比例的页面刷新回磁盘中。</li>
<li>在MySQL5.7中，Buffer Pool的刷新由page cleaner threads完成:<ul>
<li>我们可以通过innodb_page_cleaners参数控制page cleaner threads线程的数量，但是当你将这个数值调整的比Buffer Pool的数量还大时，MySQL会自动将 innodb_page_cleaners数量设置为innodb_buffer_pool_instances的数量。</li>
<li>Innodb1.1.x之前需要保证LRU列表中有至少100个空闲页可以使用。低于这个阈值就会触发脏页的刷新。</li>
<li>从MySQL5.6，也就是innodb1.2.X开始，innodb_lru_scan_depth参数为每个缓冲池实例指定page cleaner threads 扫描Buffer Pool来查找要刷新的脏页的下行距离。默认为1024，该后台线程每秒都会执行一次。</li>
</ul>
</li>
<li>当脏数据页太多时，也会触发将脏数据页刷新回磁盘。该机制可由参数<code>innodb_nax_dirty_pages_pct</code>控制，比如将其设置为75，表示，当Buffer Pool中的脏数据页达到整体缓存的75%时，触发刷新的动作。现实情况是该参数默认值为0。以此来禁用Buffer Pool早期的刷新行为。</li>
<li>当redo log不可用时，也会强制脏页列表中的脏页刷新回磁盘。这个机制同样由一个后台线程完成。</li>
</ol>
<h6 id="关于脏页刷新其他知识点"><a href="#关于脏页刷新其他知识点" class="headerlink" title="关于脏页刷新其他知识点"></a>关于脏页刷新其他知识点</h6><p><strong>刷新临接数据页</strong>：意思是当MySQL将某脏页刷新回磁盘时，是否也以相同的态度将该脏页邻接的脏页一并刷新回磁盘。</p>
<p>可以通过参数innodb_flush_neighbors控制该过程。</p>
<ul>
<li>设置为0时表示，禁用刷新邻接的功能。</li>
<li>设置为1时表示，以相同的态度刷新其邻接的脏页。</li>
<li>设置为2时表示，以相同的程度刷新脏页。</li>
</ul>
<p><strong><font color=Red>那如何选择将其设置为哪种状态呢？</font></strong></p>
<p>你可以根据MySQL实例所在机器的存储类型来决定。如果为HDD存储建议将其开启，因为HDD的磁盘刷新速率较低，开启该参数后可以有效的减少IO操作。相反如果使用SSD存储，其本身就有高磁盘IO的特性，建议禁用该参数。</p>
<h5 id="BufferPool中的LRU-List"><a href="#BufferPool中的LRU-List" class="headerlink" title="BufferPool中的LRU-List"></a>BufferPool中的LRU-List</h5><h6 id="传统的LRU链表"><a href="#传统的LRU链表" class="headerlink" title="传统的LRU链表"></a>传统的LRU链表</h6><p>通过前面的内容我们知道了MySQL的Buffer Pool机制以及MySQL组织数据的最小单位是数据页。</p>
<p>并且我们也知道了 数据页在Buffer Pool中是以LRU链表的数据结构组织在一起的。</p>
<p>其实所谓的LRU链表本质上就是一个双向循环链表，如下图：</p>
<p><img data-src="/2021/07/26/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Buffer-Pool%E8%AF%A6%E8%A7%A3/02.png"></p>
<p>下面我们结合LRU链表和数据页机制描述一下MySQL加载数据的机制：</p>
<p>我们将从磁盘中读取的数据页称为young page，young page会被直接放在链表的头部。已经存在于LRU链表中数据页如果被使用到了，那么该数据页也被认为是young page而被移动到链表头部。这样链表尾部的数据就是最近最少使用的数据了，当Buffer Pool容量不足，或者后台线程主动刷新数据页时，就会优先刷新链表尾部的数据页。</p>
<h6 id="传统LRU链表有什么不足"><a href="#传统LRU链表有什么不足" class="headerlink" title="传统LRU链表有什么不足"></a>传统LRU链表有什么不足</h6><blockquote>
<p><em><strong>相信你之前肯定听说过操作系统级别的空间局部性原理：</strong></em></p>
<p><em><strong>spatial locality（空间局部性）：也就是说读取一个数据，在它周围内存地址存储的数据也很有可能被读取到，于是操作系统会帮你预读一部分数据。</strong></em></p>
</blockquote>
<p><em><strong>MySQL也是存在预读机制的。</strong></em></p>
<ul>
<li>当Buffer Pool中存储着一个区中13个连续的数据页时，你再去这个区里面读取，MySQL就会将这个区里面所有的数据页都加载进Buffer Pool中的LRU链表中。（<em>然后可能你根本不会使用这些被预读的数据页</em>）</li>
<li>当你顺序的访问了一个区中大于 innndb_read_ahead_threshold=56个数据页时，MySQL会自动帮你将下一个相邻区中的数据页读入LRU链表中。（<em>这个机制默认是被关闭的</em>）</li>
<li>当你执行select * from xxx;时，如果表中的数据页非常多，那这些数据页就会一一将Buffer Pool中的经常使用的缓存页挤下去，可能导致留在LRU链表中的全部是你不经常使用的数据。</li>
</ul>
<p>综上：你可以发现，所谓的预读机制的优势，在一定程度上违背了LRU去实现将最近最少使用的数据页刷入磁盘的设计初衷。</p>
<h6 id="MySQL中的LRU链表"><a href="#MySQL中的LRU链表" class="headerlink" title="MySQL中的LRU链表"></a>MySQL中的LRU链表</h6><p>MySQL的LRU链表长下面这样:</p>
<p><img data-src="/2021/07/26/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89Buffer-Pool%E8%AF%A6%E8%A7%A3/03.png"></p>
<p>LRU链表被MidPoint分成了New Sublist和Old Sublist两部分。</p>
<p>其中New Sublist大概占比5/8，Old Sublist占比3/8。</p>
<p>New Sublist存储着young page，而Old Sublist存储着Old Page。</p>
<p>我们可以通过如下的方式查看MidPoint的默认值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%innodb_old_blocks_pct%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h6 id="MySQL定制的LRU链表的优势"><a href="#MySQL定制的LRU链表的优势" class="headerlink" title="MySQL定制的LRU链表的优势"></a>MySQL定制的LRU链表的优势</h6><p>而对于MySQL的LRU链表来说，通过MidPoint将链表分成两部分。</p>
<p>从磁盘中新读出的数据会放在Old Sublist的头部。</p>
<p>这样即使你真的使用select * from t;也不会导致New Sublist中的经常被访问的数据页被刷入磁盘中。</p>
<p>正常情况下，访问Old Sublist中的缓存页，那么该缓存页会被提升到New Sublist中成为热数据。</p>
<p>但是当你通过 select * from t将一大批数据加载到Old Sublist时，然后在不到1s内你又访问了它，那在这段时间内被访问的缓存页并不会被提升为热数据。这个1s由参数 <em><strong>innodb_old_blocks_time</strong></em> 控制。</p>
<p><em><strong>另外：New SubList也是经过优化的，如果你访问的是New SubList的前1/4的数据，它是不会被移动到LRU链表头部去的。</strong></em></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
</search>
